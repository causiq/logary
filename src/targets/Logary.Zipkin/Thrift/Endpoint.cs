/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Text;
using Thrift.Protocol;

namespace Logary.Zipkin.Thrift
{
    /// <summary>
    /// Indicates the network context of a service recording an annotation with two
    /// exceptions.
    /// 
    /// When a BinaryAnnotation, and key is CLIENT_ADDR or SERVER_ADDR,
    /// the endpoint indicates the source or destination of an RPC. This exception
    /// allows zipkin to display network context of uninstrumented services, or
    /// clients such as web browsers.
    /// </summary>
#if !SILVERLIGHT
    [Serializable]
#endif
    internal sealed class Endpoint : TBase
    {
        private int _ipv4;
        private short _port;
        private string _service_name;

        /// <summary>
        /// IPv4 host address packed into 4 bytes.
        /// 
        /// Ex for the ip 1.2.3.4, it would be (1 << 24) | (2 << 16) | (3 << 8) | 4
        /// </summary>
        public int Ipv4
        {
            get
            {
                return _ipv4;
            }
            set
            {
                __isset.ipv4 = true;
                this._ipv4 = value;
            }
        }

        /// <summary>
        /// IPv4 port or 0, if unknown.
        /// 
        /// Note: this is to be treated as an unsigned integer, so watch for negatives.
        /// </summary>
        public short Port
        {
            get
            {
                return _port;
            }
            set
            {
                __isset.port = true;
                this._port = value;
            }
        }

        /// <summary>
        /// Classifier of a source or destination in lowercase, such as "zipkin-web".
        /// 
        /// This is the primary parameter for trace lookup, so should be intuitive as
        /// possible, for example, matching names in service discovery.
        /// 
        /// Conventionally, when the service name isn't known, service_name = "unknown".
        /// However, it is also permissible to set service_name = "" (empty string).
        /// The difference in the latter usage is that the span will not be queryable
        /// by service name unless more information is added to the span with non-empty
        /// service name, e.g. an additional annotation from the server.
        /// 
        /// Particularly clients may not have a reliable service name at ingest. One
        /// approach is to set service_name to "" at ingest, and later assign a
        /// better label based on binary annotations, such as user agent.
        /// </summary>
        public string ServiceName
        {
            get
            {
                return _service_name;
            }
            set
            {
                __isset.service_name = true;
                this._service_name = value;
            }
        }


        internal Isset __isset;
#if !SILVERLIGHT
        [Serializable]
#endif
        internal struct Isset
        {
            public bool ipv4;
            public bool port;
            public bool service_name;
        }

        public Endpoint()
        {
        }

        public Endpoint(int ipv4, short port, string serviceName)
        {
            Ipv4 = ipv4;
            Port = port;
            ServiceName = serviceName;
        }

        public void Read(TProtocol iprot)
        {
            iprot.IncrementRecursionDepth();
            try
            {
                TField field;
                iprot.ReadStructBegin();
                while (true)
                {
                    field = iprot.ReadFieldBegin();
                    if (field.Type == TType.Stop)
                    {
                        break;
                    }
                    switch (field.ID)
                    {
                        case 1:
                            if (field.Type == TType.I32)
                            {
                                Ipv4 = iprot.ReadI32();
                            }
                            else
                            {
                                TProtocolUtil.Skip(iprot, field.Type);
                            }
                            break;
                        case 2:
                            if (field.Type == TType.I16)
                            {
                                Port = iprot.ReadI16();
                            }
                            else
                            {
                                TProtocolUtil.Skip(iprot, field.Type);
                            }
                            break;
                        case 3:
                            if (field.Type == TType.String)
                            {
                                ServiceName = iprot.ReadString();
                            }
                            else
                            {
                                TProtocolUtil.Skip(iprot, field.Type);
                            }
                            break;
                        default:
                            TProtocolUtil.Skip(iprot, field.Type);
                            break;
                    }
                    iprot.ReadFieldEnd();
                }
                iprot.ReadStructEnd();
            }
            finally
            {
                iprot.DecrementRecursionDepth();
            }
        }

        public void Write(TProtocol oprot)
        {
            oprot.IncrementRecursionDepth();
            try
            {
                TStruct struc = new TStruct("Endpoint");
                oprot.WriteStructBegin(struc);
                TField field = new TField();
                if (__isset.ipv4)
                {
                    field.Name = "ipv4";
                    field.Type = TType.I32;
                    field.ID = 1;
                    oprot.WriteFieldBegin(field);
                    oprot.WriteI32(Ipv4);
                    oprot.WriteFieldEnd();
                }
                if (__isset.port)
                {
                    field.Name = "port";
                    field.Type = TType.I16;
                    field.ID = 2;
                    oprot.WriteFieldBegin(field);
                    oprot.WriteI16(Port);
                    oprot.WriteFieldEnd();
                }
                if (ServiceName != null && __isset.service_name)
                {
                    field.Name = "service_name";
                    field.Type = TType.String;
                    field.ID = 3;
                    oprot.WriteFieldBegin(field);
                    oprot.WriteString(ServiceName);
                    oprot.WriteFieldEnd();
                }
                oprot.WriteFieldStop();
                oprot.WriteStructEnd();
            }
            finally
            {
                oprot.DecrementRecursionDepth();
            }
        }

        public override string ToString()
        {
            StringBuilder __sb = new StringBuilder("Endpoint(");
            bool __first = true;
            if (__isset.ipv4)
            {
                if (!__first) { __sb.Append(", "); }
                __first = false;
                __sb.Append("Ipv4: ");
                __sb.Append(Ipv4);
            }
            if (__isset.port)
            {
                if (!__first) { __sb.Append(", "); }
                __first = false;
                __sb.Append("Port: ");
                __sb.Append(Port);
            }
            if (ServiceName != null && __isset.service_name)
            {
                if (!__first) { __sb.Append(", "); }
                __first = false;
                __sb.Append("Service_name: ");
                __sb.Append(ServiceName);
            }
            __sb.Append(")");
            return __sb.ToString();
        }
    }
}
